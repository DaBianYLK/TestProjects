#pragma comment(lib, "TestUtils.lib")

#include "DBLog.h"
#include "DBTimer.h"

#include <iostream>

using namespace std;
using namespace DaBianYLK;

/* 
 * 测试目的：判断浮点数四则运算之间的效率差异
 *
 * 测试方法：运行四则运算各1亿次，比较消耗的时间
 *
 * Debug模式下Profile结果――每种运算函数的CPU占用百分比：
 *		乘法 6.29%
 *		除法 42.86%
 *		加法 5.98%
 *		减法 6.32%
 *
 * Release模式下计时结果：
 *		乘法 0.147805s
 *		除法 4.411531s
 *		加法 0.088647s
 *		减法 0.087332s
 *
 * 结果分析：
 *		1. 浮点数乘法、加减法效率相近，除法效率最低
 *		2. 在Release模式下，浮点数乘法效率与除法的时间消耗比约为 1 ： 30
*
* 结论：
*		在希望效率最大化的情况下，需要尽量避免浮点数除法运算：
*		1. 精度要求不高时可以改为整数除法运算或移位运算
*		2. 多次除以同一个变量时，先转化为倒数，再使用乘法
 */

inline float Mul(float a, float b) {
	return a * b;
}

inline float Div(float a, float b) {
	return a / b;
}

inline float Add(float a, float b) {
	return a + b;
}

inline float Sub(float a, float b) {
	return a - b;
}

int main(void) {
	const unsigned int nCalculation = 99999999;

	// ************************* 乘法 *************************
	float factor = 1.11112f;
	float result = 12345.0f;

	BENCHMARK_START(
		Multiple, 
		for (unsigned int i = 0; i < nCalculation; ++i) {
			result = Mul(result, factor);
		}
	);

	// 这里要输出一次result,否则编译器的优化会删除执行运算的代码
	Log("Past Time : %fs, Result : %f", BENCHMARK_RESULT(Multiple), result);	

	// ************************* 除法 *************************
	factor = 1.11112f;
	result = 12345.0f;

	BENCHMARK_START(
		Division,
		for (unsigned int i = 0; i < nCalculation; ++i) {
			result = Div(result, factor);
		}
	);

	// 这里要输出一次result,否则编译器的优化会删除执行运算的代码
	Log("Past Time : %fs, Result : %f", BENCHMARK_RESULT(Division), result);	

	// ************************* 加法 *************************
	factor = 1.11112f;
	result = 12345.0f;

	BENCHMARK_START(
		Addition,
		for (unsigned int i = 0; i < nCalculation; ++i) {
			result = Add(result, factor);
		}
	);

	// 这里要输出一次result,否则编译器的优化会删除执行运算的代码
	Log("Past Time : %fs, Result : %f", BENCHMARK_RESULT(Addition), result);	

	// ************************* 减法 *************************
	factor = 1.11112f;
	result = 12345.0f;

	BENCHMARK_START(
		Subtraction,
		for (unsigned int i = 0; i < nCalculation; ++i) {
			result = Sub(result, factor);
		}
	);

	Log("Past Time : %fs, Result : %f", BENCHMARK_RESULT(Subtraction), result);	// 这里要输出一次result,否则编译器的优化会删除执行运算的代码

	system("pause");

	return 0;
}